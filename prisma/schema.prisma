// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  clerkUserId String   @unique
  email       String?
  uniqueName  String?  @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  walletAddresses WalletAddress[]
  products        Product[]
  paymentIntents  PaymentIntent[]

  @@map("users")
}

model WalletAddress {
  id          String   @id @default(cuid())
  userId      String   // Now stores Clerk user ID
  address     String
  addressId   String   // BlockRadar's internal address ID
  addressName String
  chain       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations - Reference clerkUserId instead of id
  user User @relation(fields: [userId], references: [clerkUserId], onDelete: Cascade)

  // Unique constraints
  @@unique([userId, chain])
  @@unique([addressId])
  @@map("wallet_addresses")
}

model Product {
  id             String   @id                    // Custom product ID (pr_xxx)
  userId         String   // Now stores Clerk user ID
  image          String?
  productName    String
  description    String
  amount         String
  payoutChain    String   // Chain for payout (e.g., 'base', 'solana', 'tron')
  payoutToken    String   // Token for payout (e.g., 'USDC', 'USDT')
  paymentLink    String
  slug           String
  linkExpiration String   // 'never' or 'custom_days'
  customDays     Int?
  expiresAt      DateTime?
  status         String   @default("active") // 'active', 'expired', 'cancelled'
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations - Reference clerkUserId instead of id
  user User @relation(fields: [userId], references: [clerkUserId], onDelete: Cascade)

  // Unique constraints
  @@unique([userId, slug])
  @@map("products")
}

enum PaymentIntentStatus {
  INITIATED
  PROCESSING
  PENDING
  REQUIRES_ACTION
  MICRODEPOSITS_VERIFIED
  SUCCEEDED
  FAILED
  CANCELLED
}

model PaymentIntent {
  id                 String                @id @default(cuid())   // Auto-generated database ID
  userId             String                // Now stores Clerk user ID
  productId          String                // Product ID (pr_xxx) - reference to the product
  slug               String                // Product slug - used to find the product
  userUniqueName     String                // User's unique name - for payment link generation
  paymentIntentId    String                @unique               // Stripe payment intent ID (unique)
  clientSecret       String                @unique               // Stripe client secret (unique)
  amount             Int                   // Amount in cents
  currency           String                // Currency code (USD, EUR, etc.)
  paymentMethodTypes String[]              @default([])          // Payment method types from Stripe (e.g., ["card", "link"] or ["us_bank_account"])
  status             PaymentIntentStatus   @default(INITIATED)   // Payment intent status
  customerName       String?               // Customer billing name from Stripe
  customerEmail      String?               // Customer billing email from Stripe
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt

  // Relations - Reference clerkUserId instead of id
  user User @relation(fields: [userId], references: [clerkUserId], onDelete: Cascade)

  // Unique constraints
  @@unique([userId, slug, paymentIntentId])
  @@map("payment_intents")
}
